<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: graphvisualization.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: graphvisualization.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

let nodeRadius = 8;

/**
eval the script in the text area #script
*/
function evalScript() {
  try {
    noerror();
    eval($('#script').val());
  } catch (e) {
    error(e);
  } finally { }
}





let previousGraph = undefined;

function savePreviousGraph()
{
  previousGraph = new Array();
  getSVG().selectAll("g.node")
    .each(function (d) {
        previousGraph[d.id] = {x: d.x, y: d.y};});
}


function setNodePositionRespectingPreviousGraph()
{
  getSVG().selectAll("g.node")
    .each(function (d) {
      let previousID = getWorldFromWorldAction(d.id);
      let previousGraphInfo =  previousGraph[previousID];
      if(previousGraphInfo != undefined)
      {
        if(previousGraphInfo.x != undefined) d.x = previousGraphInfo.x;
        if(previousGraphInfo.y != undefined) d.y = previousGraphInfo.y;
      }
  });
}



/**
@param M epistemic modelCheck
@param W0 set of initial world IDs
@param E action modelCheck
@param E0 set of initial event IDs
@param t = depth
*/
function showMEstar(M, W0, E, E0, t) {
  savePreviousGraph();

  showGraph(getDataSetFromMEt(M, W0, E, E0, t), t!=0);
  simulation.stop();
  setNodePositionRespectingPreviousGraph();
  setTimeout(() => simulation.restart(), 200);
}



/**
@param datase data of the graph in the D3 format
@param isManyEpistemicModel true iff there exists multiple epistemic models to display (somehow if the depth is > 0). This value modifies the display.
*/
function showGraph(dataset, isManyEpistemicModel)
{
  if(isManyEpistemicModel) {
    agents.each(agent => setLoopDrawn(agent));
  }
  SVGclear();
  linksTolinksForD3(dataset);

//  setTimeout(() => forceSetup(dataset, isManyEpistemicModel), 1000);
  forceSetup(dataset, isManyEpistemicModel);
    edgesSetup(dataset);
    nodesSetup(dataset);
}

let optionIsLoopDrawn = new Array();

function setLoopDrawn(agent, value) {
  optionIsLoopDrawn[agent] = value;
}

function isLoopDrawn(agent) {
  return optionIsLoopDrawn[agent];
}

let optionIsNodeLabelsDrawn = true;

function datasetAddM(dataset, M, t, W0) {
  for(let agent of agents) {
    setLoopDrawn(agent, !M.isReflexive(agent));
  }

  if(M.getNodesNumber() > 20)
    optionIsNodeLabelsDrawn = false;
  else {
    optionIsNodeLabelsDrawn = true;
  }

  for(let nodeID in M.getNodes())
  {
    let description = M.getNode(nodeID).getShortDescription();
    description = description.slice(0, 40);

    let initial = (W0.indexOf(nodeID) > -1);

    if(t == 0)
      dataset.nodes.push({"id": nodeID, "label": description, "group": t, "initial": initial});
    else
          dataset.nodes.push({"id": nodeID, "label": description, "group": t, "initial": initial});

  }


  M.edgesForEach(function(agent, nodeSourceID, nodeTargetID) {
      if(M.isEdge(agent, nodeTargetID, nodeSourceID))
      {
        if(nodeSourceID &lt; nodeTargetID)
          dataset.links.push({"source": nodeSourceID,
                            "target": nodeTargetID,
                            "label": agent,
                            "doubledirection": true,
                            "epistemicrelation": true,
                          "timerelation": false});
          else if (nodeSourceID == nodeTargetID)
          {
            if(isLoopDrawn(agent))
            dataset.links.push({"source": nodeSourceID,
                              "target": nodeTargetID,
                              "label": agent,
                              "loop": true,
                              "epistemicrelation": true,
                            "timerelation": false});
          }
      }
      else
          dataset.links.push({"source": nodeSourceID,
                          "target": nodeTargetID,
                          "label": agent,
                          "epistemicrelation": true,
                        "timerelation": false});
  });

}




function datasetAddEdgesBetweenMlastAndM(dataset, Mlast, M, E)
{
  for(let node in Mlast.nodes)
      for(let event in E.nodes)
      if(M.getNode(createWorldActionName(node, event)) != undefined)
          dataset.links.push({"source": node,
                            "target": createWorldActionName(node, event),
                            "label": event,
                            "epistemicrelation": false,
                          "timerelation": true});
}



/**
  @example getTuplesWorldEvent(["w", "u"], ["e", "f"])
*/
function getTuplesWorldEvent(W0, E0){
  let newW0 = new Array();
  W0.forEach(w => E0.forEach(e => newW0.push(createWorldActionName(w, e))));
  return newW0;
}




function getDataSetFromMEt(M, W0, E, E0, tmax) {
  var Mlast = undefined;
  var dataset = {nodes: [], links: []};

  for(let t = 0; t &lt;= tmax; t++) {
      if(t >= 0) {
          datasetAddM(dataset, M, t, W0);
          if(Mlast != undefined)
              datasetAddEdgesBetweenMlastAndM(dataset, Mlast, M, E);

          Mlast = M;
      }

      if(t &lt; tmax) {
        M = product(M, E);
        W0 = getTuplesWorldEvent(W0, E0);

        W0 = W0.filter(w => M.getNode(w) != undefined);
        M.removeUnReachablePartFrom(W0);
      }

  }
  return dataset;
}





let simulation;


function linksTolinksForD3(dataset)
{
  let nodeById = d3.map(dataset.nodes, d => d.id);
  dataset.links.forEach(function(link) {
    var s = link.source = nodeById.get(link.source),
        t = link.target = nodeById.get(link.target);
  });
  return dataset.links;
}


function getSVGIdFromNodeID(nodeId) {
  return "graphNode" + nodeId;
}


function graphNodeHighlight(nodeID) {
  $(".node circle").attr("class", "");
  $("#" + getSVGIdFromNodeID(nodeID) + " circle").attr("class", "highlight");
}



function graphNodeNoHighlight() {
  $(".node circle").attr("class", "");
}

function nodesSetup(dataset) {
  var nodeEnter = getSVG().selectAll("g.node")
       .data(dataset.nodes, function (d) {return d.id})
       .enter()
       .append("g")
       .attr("class", "node")
       .attr("id", function(d) {return getSVGIdFromNodeID(d.id);})
       .append("circle")
       .attr("r", nodeRadius)
       .attr("stroke", "black")
       .attr("stroke-width", d => d.initial ? 3 : 1)
       .call(d3.drag()
                 .on("start", dragstarted)
                 .on("drag", dragged)
                 .on("end", dragended))
      .on("mousemove", nodeMouseMove)
      .on("click", nodeClick)
      .each( function (d) {
        d.y = getGroupPositionCenter(d.group).y;})
        .append("svg:title")
          .text(function(d, i) { return d.label; });


        function nodeMouseMove(d) {
          $("#nodeID").html(d.id);
        }

        function nodeClick(d) {
          showWorld(d.id);
        }

       function dragstarted(d) {
         if (!d3.event.active) simulation.alphaTarget(0.3).restart();
         d.fx = d.x;
         d.fy = d.y;
       }

       function dragged(d) {
         d.fx = d3.event.x;
         d.fy = d3.event.y;
       }

       function dragended(d) {
         if (!d3.event.active) simulation.alphaTarget(0);
         d.fx = null;
         d.fy = null;
       }

     var text = getSVG().append("g").attr("class", "labels").selectAll("g")
         .data(dataset.nodes)
       .enter().append("g");

    if(optionIsNodeLabelsDrawn)
     text.append("text")
         .attr("x", 14)
         .attr("class", "nodelabel")
         .attr("y", ".31em")
         .style("font-family", "sans-serif")
         .style("font-size", d => labelLengthToFontSize(d.label.length))
         .text(d => d.label);




}


function labelLengthToFontSize(length)
{
  let fontsize = 16-1*(length);
  return Math.max(fontsize, 8);
}


function arrowsSetup()
{
  getSVG().append("defs").append("marker")
    .attr("id", "arrow")
    .attr("viewBox", "0 -5 10 10")
    .attr("refX", 20)
    .attr("refY", 0)
    .attr("markerWidth", 8)
    .attr("markerHeight", 8)
    .attr("orient", "auto")
    .append("svg:path")
    .attr("stroke", "black")
    .attr("fill", "none")
    .attr("d", "M0,-5L10,0L0,5");

    for(let a of agents)
    {
      getSVG().append("defs").append("marker")
        .attr("id", "arrow" + a)
        .attr("viewBox", "0 -5 10 10")
        .attr("refX", 20)
        .attr("refY", 0)
        .attr("markerWidth", 8)
        .attr("markerHeight", 8)
        .attr("orient", "auto")
        .append("svg:path")
        .attr("stroke", edgeLabelToColor(a))
        .attr("fill", "none")
        .attr("d", "M0,-5L10,0L0,5");

        getSVG().append("defs").append("marker")
          .attr("id", "arrowstart" + a)
          .attr("viewBox", "0 5 10 10")
          .attr("refX", -20)
          .attr("refY", 0)
          .attr("markerWidth", 8)
          .attr("markerHeight", 8)
          .attr("orient", "auto")
          .append("svg:path")
          .attr("stroke", edgeLabelToColor(a))
          .attr("fill", "none")
          .attr("d", "M0,5L10,0L0,5");
    }
}

function edgesSetup(dataset)
{
    arrowsSetup();
//http://stackoverflow.com/questions/39439608/d3-4-0-graph-with-directed-edges-and-labels
  var link = getSVG().append("g")
        .attr("class", "links")
      .selectAll("path")
        .data(dataset.links)
      .enter().append("path")
        .attr("class", "link")
        .attr("stroke-width", function(d) {if(d.doubledirection) return 1.5; else return 1;})
        .attr("stroke", function(d) { return edgeLabelToColor(d.label); })
        .attr("id", function(d, i) { return "linkId" + i; })
        .attr("fill", "none")
        /*.attr('marker-start', function(d){
              if(isLinkTime(d) || isLinkLoop(d))
                return "";
              else if(d.doubledirection)
                     return 'url(#arrowstart' + d.label + ')';
                   })*/
        .attr("marker-end",  function(d) {
          if(isLinkLoop(d) || d.doubledirection)
            return "";
          else if(isLinkTime(d))
              return "url(#arrow)";
          else
              return "url(#arrow" + d.label + ")";
        }) //add arrow of id "arrow" or "arrowa", "arrowb", etc.


    var edgelabels = getSVG().append("g").attr("class", "labels").selectAll("g")
        .data(dataset.links)
      .enter()
      .append("text")
        /*.attr("x", 0)
        .attr("y", 0)*/
        .style("font-family", "sans-serif")
        .style("font-size", "0.5em")
        .style("fill", "white")
        .style("stroke", "black")
        .text(function(d,i) {
          if(isLinkTime(d))
              return d.label;
            else {
              return "";
            }
          });

    /*  edgelabels.append("textPath")
      .attr("xlink:href",function(d,i) { return "#linkId" + i;})
      .style("pointer-events", "none")*/

}


function getGraphCenterX() {
  return 200;
}


function getGraphCenterY() {
  return 200;
}


var distanceBetweenGroups = 200;

function getGroupPositionCenter(group) {
  return {x: getGraphCenterX(), y: distanceBetweenGroups*(group)};
}




function getEpistemicRelationLinks(links) {
  let linkswithforces = [];

  for(let l of links) {
      if(l.epistemicrelation &amp;&amp; (l.source.id != l.target.id))
        linkswithforces.push(l);
  }

  return linkswithforces;
}


function getTimeRelationLinks(links) {
  var linkswithforces = [];

  for(let l of links) {
      if(!l.epistemicrelation)
        linkswithforces.push(l);
  }

  return linkswithforces;
}




function forceSetup(dataset, isManyEpistemicModel) {
  var manyBody = d3.forceManyBody(dataset.nodes).strength(-30);
//  var networkCenter = d3.forceCenter().x(getGraphCenterX()).y(getGraphCenterY());

  var forceY = d3.forceY(function (d) {return getGroupPositionCenter(d.group).y;})
//        .strength(0.15);

  simulation = d3.forceSimulation(dataset.nodes)
//      .force("collide",d3.forceCollide(function(d){return 16}))
     .force("charge", manyBody)
      .force("link", d3.forceLink(getEpistemicRelationLinks(dataset.links)).distance(96))//.iterations(1))
  //   .force("link2", d3.forceLink(getTimeRelationLinks(dataset.links)))//.distance(0).iterations(1)) &lt;== fait bugger le truc
    // .force("center", networkCenter)
    //  .force("x", forceX)
   simulation.stop();
    if(isManyEpistemicModel)
        simulation
          .force("y", forceY);

    simulation
     .on("tick", updateNetwork);

     function updateNetwork(e) {


       let xmin = 0;
       let ymin = 0;
       let xmax = 0;
       let ymax = 0;

         getSVG().selectAll("g.node")
           .attr("transform", function (d) {
              xmin = Math.min(d.x - 2*nodeRadius, xmin);
              ymin = Math.min(d.y - 2*nodeRadius, ymin);
              xmax = Math.max(d.x + 2*nodeRadius, xmax);
              ymax = Math.max(d.y + 2*nodeRadius, ymax);

              return "translate(" + d.x + "," + d.y + ")"});

        if(optionIsNodeLabelsDrawn)
         getSVG().selectAll("text")
           .attr("transform", function (d) {
              if(d.x == undefined) //label of an edge
                return "translate(" + (d.source.x + d.target.x)/2 + "," + (d.source.y + d.target.y)/2 + ")";
              else { //label of a node
                return "translate(" + d.x + "," + d.y + ")"
                }
              });


         getSVG().selectAll("line")
         .attr("x1", function (d) {return d.source.x})
         .attr("y1", function (d) {return d.source.y})
         .attr("x2", function (d) {return d.target.x})
         .attr("y2", function (d) {return d.target.y});



         getSVG().selectAll(".link").attr("d", function(d) {
            if(isLinkTime(d))
            {
                return "M" + d.source.x + "," +
                d.source.y + "L" + d.target.x + "," +
                d.target.y;

            }
            else {


              //let factorCurve = {"a": 1, "b":1.3, "c":1.6};
              let factorCurve = {"a": 1.5, "b":1.9, "c":2.3};
              var x1 = d.source.x;
              var y1 = d.source.y;
              var x2 = d.target.x;
              var y2 = d.target.y;


              var dx = d.target.x - d.source.x,
                  dy = d.target.y - d.source.y,
                  dr = Math.sqrt(dx * dx + dy * dy)*factorCurve[d.label];


            if ( dx ==0 &amp;&amp; dy == 0 ) {
                    let factorCurve = {"a": 1, "b":1, "c":1.3};
                    let xRotation = 0;

                    // Needs to be 1.
                    let largeArc = 1;
                    let sweep;

                    // Change sweep to change orientation of loop.
                    if(d.label == "a")
                        sweep = 0;
                    else
                        sweep = 1;

                    // Make drx and dry different to get an ellipse
                    // instead of a circle.
                    let drx = 8*factorCurve[d.label];
                    let dry = 8*factorCurve[d.label];

                    // For whatever reason the arc collapses to a point if the beginning
                    // and ending points of the arc are the same, so kludge it.
                    x2 = x2 + 1;
                    y2 = y2 + 1;

                    return "M" + x1 + "," + y1 + "A" + drx + "," + dry + " " + xRotation + "," + largeArc + "," + sweep + " " + x2 + "," + y2;
                  }

              return "M" +
                  d.source.x + "," +
                  d.source.y + "A" +
                  dr + "," + dr + " 0 0,1 " +
                  d.target.x + "," +
                  d.target.y;
            }


    });





      //    getSVG().attr("viewBox", xmin + " " + ymin + " 1000 1000");
      let viewPortWidth = (xmax-xmin);
      let viewPortHeight = (ymax-ymin);


      if(viewPortWidth &lt; getSVGWidth())
        viewPortWidth = getSVGWidth();


      if(viewPortHeight &lt; getSVGHeight())
        viewPortHeight = getSVGHeight();


      getSVG().attr("viewBox", xmin + " " + ymin + " " + viewPortWidth  + " " + viewPortHeight);







       }

}






function getSVG() {
  return d3.select("svg.main");
}



function SVGclear() {
    d3.selectAll("svg > *").remove();
}






function edgeLabelToColor(label)
{
  if(label == "a")
      return "#ff2255";
  else if(label == "b")
      return "#4444ff";
  else if(label == "c")
          return "#ffd800";
  else
    return "#ccc";

}


function getLinkLabel(d) {
  return d.label;
}


function isLinkTime(d) {
  return !(["a", "b", "c"].indexOf(d.label) > -1);

}



function isLinkLoop(d)
{
  return d.target.id == d.source.id;
}

function getLinkPosition(d) {
  return "M" + d.source.x + "," + d.source.y
       + "L " + d.target.x + "," + d.target.y;
}

function getLinkSourceX(d) {
  return d.source.x;
}


function getLinkSourceY(d) {
  return d.source.y;
}


function getLinkTargetX(d) {
  return d.target.x;
}


function getLinkTargetY(d) {
  return d.target.y;
}



function setPointInsideBoundedBox(d)
{
  let width = getSVG().attr("width");
  let height = getSVG().attr("height");
  d.x = Math.max(nodeRadius, Math.min(width - nodeRadius, d.x));
  d.y = Math.max(nodeRadius, Math.min(height - nodeRadius, d.y));
}



function getSVGWidth()
{
  return $('svg').width();
}



function getSVGHeight()
{
  return $('svg').height();
}







function getTikzCode()
{

  function tikzscale(x)
  {
      return (x / 20).toFixed(3);
  }



  let tikzCode = "\\begin{tikzpicture}[scale=0.95]\n";
  tikzCode += "\\tikzstyle{agenta} = [red];\n";
  tikzCode += "\\tikzstyle{agentb} = [blue];\n";
  tikzCode += "\\tikzstyle{agentc} = [orange];\n";
  tikzCode += "\\tikzstyle{world} = [draw];\n"
  getSVG().selectAll("g.node")
    .each(function (d) {
        tikzCode += "\\node[world] (" + d.id + ") at (" + tikzscale( d.x ) + ", " + tikzscale(d.y) + ") {" + d.label + "};\n";
    });

  getSVG().selectAll(".link").each(
    function (d) {
      let optionDraw = "[agent" + d.label + ", ";
      if(!d.doubledirection)
        optionDraw += "->";

      optionDraw += "]";


      let optionEdge = "";

      if(d.source.id == d.target.id)
        optionEdge = "[loop above]";
       tikzCode += "\\draw" + optionDraw + "(" + d.source.id + ") edge" + optionEdge + " (" + d.target.id + ");\n";
    }

  )

  tikzCode += "\\end{tikzpicture}";
  return tikzCode;
}









$(function () {
    // définition de la boîte de dialogue
    // la méthode jQuery dialog() permet de transformer un div en boîte de dialogue et de définir ses boutons
    $( "#codeTikzDialog" ).dialog({
        autoOpen: false,
        width: 600,
        buttons: [
            {
                text: "OK",
                click: function() {
                    $( this ).dialog( "close" );
                }
            }
        ]
    });
});


    function GUIExportInTikz()
    {
        $('#codeTikz').val(getTikzCode());
        $( "#codeTikzDialog" ).dialog( "open" );
    }
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ActionModel.html">ActionModel</a></li><li><a href="ConsecutiveNumbers.html">ConsecutiveNumbers</a></li><li><a href="EpistemicModel.html">EpistemicModel</a></li><li><a href="Graph.html">Graph</a></li><li><a href="MuddyChildrenWorld.html">MuddyChildrenWorld</a></li><li><a href="PropositionalAssignmentsPostcondition.html">PropositionalAssignmentsPostcondition</a></li><li><a href="qdecPOMDP.html">qdecPOMDP</a></li><li><a href="QdecPOMDPPoliciesWorld.html">QdecPOMDPPoliciesWorld</a></li><li><a href="RussianCardsWorld.html">RussianCardsWorld</a></li><li><a href="SallyAndAnneWorld.html">SallyAndAnneWorld</a></li><li><a href="SetOfObjects.html">SetOfObjects</a></li><li><a href="TrivialPostCondition.html">TrivialPostCondition</a></li><li><a href="Valuation.html">Valuation</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addButtonAction">addButtonAction</a></li><li><a href="global.html#addButtonActionReset">addButtonActionReset</a></li><li><a href="global.html#addExplanation">addExplanation</a></li><li><a href="global.html#agentImages">agentImages</a></li><li><a href="global.html#cleanArray">cleanArray</a></li><li><a href="global.html#computeButtonsVisibleOrNot">computeButtonsVisibleOrNot</a></li><li><a href="global.html#createFormula">createFormula</a></li><li><a href="global.html#createKnowledgeBasedProgram">createKnowledgeBasedProgram</a></li><li><a href="global.html#createLitteral">createLitteral</a></li><li><a href="global.html#createWorldActionName">createWorldActionName</a></li><li><a href="global.html#esprimaToAST">esprimaToAST</a></li><li><a href="global.html#evalScript">evalScript</a></li><li><a href="global.html#formulaPrettyPrint">formulaPrettyPrint</a></li><li><a href="global.html#getOpenWorldsAfterAction">getOpenWorldsAfterAction</a></li><li><a href="global.html#getProgramCounterGraph01">getProgramCounterGraph01</a></li><li><a href="global.html#getQdecPOMDPPoliciesEventName">getQdecPOMDPPoliciesEventName</a></li><li><a href="global.html#getStringIntArrayFromStringSetTo">getStringIntArrayFromStringSetTo</a></li><li><a href="global.html#getTuplesWorldEvent">getTuplesWorldEvent</a></li><li><a href="global.html#performAction">performAction</a></li><li><a href="global.html#product">product</a></li><li><a href="global.html#products">products</a></li><li><a href="global.html#showGraph">showGraph</a></li><li><a href="global.html#showMEstar">showMEstar</a></li><li><a href="global.html#speak">speak</a></li><li><a href="global.html#unitTests">unitTests</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Mon Jun 19 2017 18:02:23 GMT+0200 (CEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
