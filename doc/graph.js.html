<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: graph.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: graph.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

/**
 * @class Graph represents a finite graph. Edges are labelled by agents.
 * @description  Create an empty graph
 */
class Graph
{
  constructor() {
  	this.nodes = new Object();
  	this.successors = new Object();
  	this.dotstyle = "";
  }

  /**
  @returns a dictionnary containing pairs (nodeid, node)
	 * */
  getNodes()
  {
    return this.nodes;
  }

  /**
   * @param inodes is an array of node identifier. If inodes is not array then
   it is as if we gave the array [inodes]
	 * @description remove all nodes that are not reachable from inode
	 * */
  removeUnReachablePartFrom(inodes)
  {
    if(!(inodes instanceof Array))
      inodes = [inodes];

    let nodesVisited = {};
    let graph = this;

    inodes.forEach(function(inode) {explore(inode);});

    function explore(inode)
    {
        if(nodesVisited[inode])
            return;
        nodesVisited[inode] = true;

        for(let a in graph.successors)
        {
          if(graph.getSuccessors(inode, a) != undefined)
          for(let inode2 of graph.getSuccessors(inode, a))
          {
            explore(inode2);
          }
        }
    }

    for(let inode2 in this.nodes)
    {
      if(nodesVisited[inode2] == undefined)
      {
        delete this.nodes[inode2];
      }

    }

  }










  /**
	 * @returns the number of nodes in the graph
	 * */
  getNodesNumber()
  {
    var c = 0;

    for(let o in this.nodes)
      c++;

    return c;
  }

  /**
	 * @param node, a node identifier
   * @param agent, an agent (label)
   * @returns an array of all successors of node via the agent
	 * */
  getSuccessors(node, agent) {
      if(!isAgent(agent)) error("The second argument " + agent + " of getSuccessors should be an agent. " + ERROR_AGENT_EXPLANATION);
      if(this.nodes[node] == undefined) error("getSuccessors : There is no source node of ID " + node);

      if(this.successors[agent] == undefined)
          return new Array();
      else if (this.successors[agent][node] == undefined)
        return new Array();
      else
           return this.successors[agent][node];
  }




/**
@param agent
@result true iff the relation for agent is reflexive (there is a self-loop over all nodes)
*/

  isReflexive(agent)
  {
      for(let inode in this.nodes)
        if(!this.isEdge(agent, inode, inode))
            return false;
      return true;
  }

  /**
  @returns a string that represents the graph in the DOT format (for graphviz)
  */
	getDOTNotation ()
	{

		var graphDOTnotation = "digraph G {\n     node " + this.dotstyle + "\n" ;

		for(var i in this.nodes)
		{
			graphDOTnotation += '"' + i + '" [label="' + this.nodes[i] + '"]\n';
		}

		var T = new Array();

		for(var a in this.successors)
		for(var i in this.successors[a])
		{
		    if(T[i] == undefined)
			  T[i] = new Array();

		    for(var j in this.successors[a][i])
		    if(i != this.successors[a][i][j]) //to comments for having the loops
		    {
		        var succ = this.successors[a][i][j];
			if(T[i][succ] == undefined)
			  T[i][succ] = new Array();

			T[i][succ].push(a);

		      }
		}



		for(var i in this.nodes)
		  for(var j in T[i])
		    if(T[i][j] != undefined)
		    {
			var label = "";
			//var comma = false;
			for(var a in T[i][j])
			{
			    /*if(comma)
			      label += "," + T[i][j][a];
			    else
			    {
			      label += T[i][j][a];
			      comma = true;
			    }*/
			    label += T[i][j][a];
			}

			var dirboth = "[";

			if(j != i)
		        if(T[j][i] != undefined)
			{
			    if(arrayIsEqual(T[i][j], T[j][i]))
			    {
				dirboth = "[dir=both, ";
				T[j][i] = undefined;
			    }

			}

		        graphDOTnotation += '"' + i + '" -> "' + j + '"' + dirboth + 'label="' + label + '"]\n';
		   }


		graphDOTnotation += "}";

		return graphDOTnotation;
	}







  /**
  @returns a clone of the graph.
  */
	copy ()
	{
		var g = new Graph();

		g.nodes = copy(this.nodes);
		g.successors = copy(this.successors);

		return g;
	}



  /**
  @param idnode is the ID of the node to be added
  @param content, an objet that is the node (for e.g. a valuation)
  @description Add a node of ID idnode and of content content
  @example G.addNode("w", new Valuation(["p"]))
  */
	addNode(idnode, content)
	{
		this.nodes[idnode] = content;
	}

  /**
  @param idnode is the ID of the node to be added
  @returns the content of the node
  */
	getNode(idnode)
	{
	    return this.nodes[idnode];
	}


  hasNode(idnode)
  {
    if(idnode in this.nodes) return true;
    return false;
  }

  /**
  @param agent
  @param idsource ID of the source node
  @param iddestination ID of the destination node
  @description Add an edge from idsource to iddestination labelled by agent
  @example G.addEdge("a", "w", "u")
  */
	addEdge(agent, idsource, iddestination)
	{
    if(!isAgent(agent)) error("The first argument " + agent + " of addEdge should be an agent. " + ERROR_AGENT_EXPLANATION);
    if(this.nodes[idsource] == undefined) error("There is no source node of ID " + idsource);
    if(this.nodes[iddestination] == undefined) error("There is no destination node of ID " + iddestination);

		if(this.successors[agent] == undefined)
		{
			this.successors[agent] = new Array();
		}

		if(this.successors[agent][idsource] == undefined)
		{

			this.successors[agent][idsource] = new Array();
		}


		if(this.successors[agent][idsource].indexOf(iddestination) &lt; 0)
		    this.successors[agent][idsource].push(iddestination);


	}



  /**
  @param agent
  @param idnodes array of node IDs
  @description Add edges between all nodes of ID in array
  @example G.addEdgesCluster("a", ["w", "u"])
  */
  addEdgesCluster(agent, idnodes)
  {
      for(let i1 of idnodes)
      for(let i2 of idnodes)
      {
        this.addEdge(agent, i1, i2);
      }
  }


  /**
  @param agent
  @param conditionFunction is a function that takes two content nodes and that returns true
  if, with respect to the contents the two nodes should be linked by an adge labelled by agent
  @description add edges labelled by agent with respect to the function conditionFunction
  @example G.addEdgeIf("a", function(n1, n2) {return n1.modelCheck("p") == n2.modelCheck("p");})
  */
  addEdgeIf(agent, conditionFunction)
  {
      for(let inode1 in this.nodes)
      for(let inode2 in this.nodes)
          if(conditionFunction(this.nodes[inode1], this.nodes[inode2]))
              this.addEdge(agent, inode1, inode2);
  }



  /**
  @param functionToCall is a function of signature (agent, idsource, iddestination)
  @description This function calls functionToCall for all edges (agent, idsource, iddestination)
  */
  edgesForEach(functionToCall)
  {
    for(var agent in this.successors)
    for(var nodeSourceID in this.nodes)
        if(this.successors[agent] != undefined)
            if(this.successors[agent][nodeSourceID] != undefined)
                for(var nodeTargetID of this.successors[agent][nodeSourceID])
                    functionToCall(agent, nodeSourceID, nodeTargetID);
  }

  /**
  @param agent
  @description The relation of agent becomes complete. That is, an edge labelled by agent
  is added between any pair of nodes
  @example G.makeCompleteRelation("a")
  */
	makeCompleteRelation(agent)
	{
	  for(let i in this.nodes)
		for(let j in this.nodes)
			this.addEdge(agent, i, j);
	}



  /**
  @param agent
  @description The relation of agent becomes reflexive. That is, a reflexive edge labelled by agent
  is added on any node
  @example G.makeReflexiveRelation("a")
  */
	makeReflexiveRelation(agent)
	{
	  for(let i in this.nodes)
			this.addEdge(agent, i, i);
	}

  /**
  @param agent
  @param idsource
  @param iddestination
  @returns true if there is an edge from idsource to iddestination  labelled by agent
  @example G.isEdge("a", "w", "u")
  */
	isEdge(agent, idsource, iddestination)
	{
		if(this.successors[agent] == undefined)
			return false;

		if(this.successors[agent][idsource] == undefined)
			return false;

		return this.successors[agent][idsource].indexOf(iddestination) > -1;

	}









    getShortestPathVisited(sourceNode, destinationNode)
    {
      let visited = {};
      let queue = [];
      queue.push(sourceNode);
      visited[sourceNode] = {distance: 0, parent: null};

      while(queue.length != 0)
      {
          let world = queue.shift();

          if(world == destinationNode)
          {
              return visited;
          }
          for(let a of agents)
          for(let u of this.getSuccessors(world, a))
          if(visited[u] == undefined)
          {
              visited[u] = {distance: visited[world].distance + 1, parent: world, agent: a};
              queue.push(u);
          }
      }
      return undefined;
    }




  /**
  @param sourceNode ID of a source node
  @param destinationNode ID of a destination node
  @returns a shortest path from sourceNode to destinationNode or undefined if
  no path exists.
  The is represented as follows:
  [{agent: a1, world: n1}, {agent: a1, world: n2}, ... {agent: ak, world: nk}]
  if the shortest path is
  sourceNode --a1--> n1 --a2--> n2 --.............. --ak--> nk = destinationNode
  @example G.getShortestPath("w", "u")
  **/
  getShortestPath(sourceNode, destinationNode)
  {
    let visited = this.getShortestPathVisited(sourceNode, destinationNode);

    if(visited == undefined)
      return undefined;

    let path = [];
    let world = destinationNode;
    while(visited[world].parent != null)
    {
      path.unshift({world: world, agent: visited[world].agent });
      world = visited[world].parent;
    }

    return path;
  }



}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ActionModel.html">ActionModel</a></li><li><a href="ConsecutiveNumbers.html">ConsecutiveNumbers</a></li><li><a href="EpistemicModel.html">EpistemicModel</a></li><li><a href="Graph.html">Graph</a></li><li><a href="MuddyChildrenWorld.html">MuddyChildrenWorld</a></li><li><a href="PropositionalAssignmentsPostcondition.html">PropositionalAssignmentsPostcondition</a></li><li><a href="qdecPOMDP.html">qdecPOMDP</a></li><li><a href="QdecPOMDPPoliciesWorld.html">QdecPOMDPPoliciesWorld</a></li><li><a href="RussianCardsWorld.html">RussianCardsWorld</a></li><li><a href="SallyAndAnneWorld.html">SallyAndAnneWorld</a></li><li><a href="SetOfObjects.html">SetOfObjects</a></li><li><a href="TrivialPostCondition.html">TrivialPostCondition</a></li><li><a href="Valuation.html">Valuation</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addButtonAction">addButtonAction</a></li><li><a href="global.html#addButtonActionReset">addButtonActionReset</a></li><li><a href="global.html#addExplanation">addExplanation</a></li><li><a href="global.html#agentImages">agentImages</a></li><li><a href="global.html#cleanArray">cleanArray</a></li><li><a href="global.html#computeButtonsVisibleOrNot">computeButtonsVisibleOrNot</a></li><li><a href="global.html#createFormula">createFormula</a></li><li><a href="global.html#createKnowledgeBasedProgram">createKnowledgeBasedProgram</a></li><li><a href="global.html#createLitteral">createLitteral</a></li><li><a href="global.html#createWorldActionName">createWorldActionName</a></li><li><a href="global.html#esprimaToAST">esprimaToAST</a></li><li><a href="global.html#evalScript">evalScript</a></li><li><a href="global.html#formulaPrettyPrint">formulaPrettyPrint</a></li><li><a href="global.html#getOpenWorldsAfterAction">getOpenWorldsAfterAction</a></li><li><a href="global.html#getProgramCounterGraph01">getProgramCounterGraph01</a></li><li><a href="global.html#getQdecPOMDPPoliciesEventName">getQdecPOMDPPoliciesEventName</a></li><li><a href="global.html#getStringIntArrayFromStringSetTo">getStringIntArrayFromStringSetTo</a></li><li><a href="global.html#getTuplesWorldEvent">getTuplesWorldEvent</a></li><li><a href="global.html#performAction">performAction</a></li><li><a href="global.html#product">product</a></li><li><a href="global.html#products">products</a></li><li><a href="global.html#showGraph">showGraph</a></li><li><a href="global.html#showMEstar">showMEstar</a></li><li><a href="global.html#speak">speak</a></li><li><a href="global.html#unitTests">unitTests</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Mon Jun 19 2017 18:02:23 GMT+0200 (CEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
