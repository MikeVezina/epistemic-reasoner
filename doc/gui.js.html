<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: gui.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: gui.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

var openWorlds = [];
/*
 if openWorld = [], no thoughts are shown
 if openWorld = [{world: "w", agent: "a"}], the real world is w and the GUI shows the thoughts of agent a
 if openWorld = [{world: "w", agent: "a"}, {world: "u", agent: "b"}], then the real world is w, the GUI shows the thouhts of agent a, in which
       there is a possible world u where we show the thoughts of agent b.
*/

var canvasFromWorld = new Array();

var levelheight= 170;

var maxlevel = 3;

var canvasWorldWidth = 128;

var worldBackgroundColor = "#55EE55";

function Rectangle(x1, y1, w, h)
{
  this.x1 = x1;
  this.y1 = y1;
  this.w = w;
  this.h = h;

  this.isPointIn = (point) =>
             (this.x1 &lt;= point.x) &amp;&amp; (point.x &lt;= this.x1 + this.w) &amp;&amp;
             (this.y1 &lt;= point.y) &amp;&amp; (point.y &lt;= this.y1 + this.h);
}




function getMaxLevelWidth()
{
    return 480;
}





function circle(context, x, y, r, fillStyle)
{
  context.beginPath();
  context.strokeStyle="black";
  context.lineWidth="1";
  context.arc(x, y, r, 0, 2 * Math.PI, false);
  context.stroke();
  if(fillStyle == undefined)
       fillStyle = "white";
  context.fillStyle = fillStyle;
  context.fill();

}

function drawThinkingCircles(context, x1, y1, x2, y2)
{
  let pas = 20;
  let imax = (y1-y2) / pas;

  let y = y1;
  let r = 5;
  for(let i = 0; i &lt;= imax; i++)
  {
      let x = x1 + (i * (x2-x1)) / imax;

      if(y-r &lt; y2)
        return;
      circle(context, x, y, r);
      y -= pas;
      r += 6;
  }
}


function getContext(canvas) {
  return canvas.getContext('2d');
}


var cumulativeOffset = function(element) {
    var top = 0, left = 0;
    do {
        top += element.offsetTop  || 0;
        left += element.offsetLeft || 0;
        top -= element.scrollTop  || 0;
        left -= element.scrollLeft || 0;
        element = element.offsetParent;
    } while(element);

    return {
        x: left,
        y: top
    };
};



function getWorldPosition(level, worldID)
{
    return cumulativeOffset(canvasFromWorld[level][worldID]);

}


function getNewCanvas()
{
  var canvas = document.createElement('canvas');
  canvas.id     = "CursorLayer";
  canvas.width  = canvasWorldWidth;
  canvas.height = 64;
  canvas.style.zIndex   = 8;
  canvas.style.position = "relative";
  canvas.style.margin = "2px 5px 5px 5px";
  canvas.className = "canvasWorld";
  return canvas;
}




function modifyOpenWorldsClick(keepLevelTil, canvasWorld, fromWorld)
{
    return function(evt)
    {
        openWorlds = openWorlds.slice(0, keepLevelTil);
        var point = getMousePos(canvasWorld, evt);

        for(let a of agents)
        {
            if(M.getNode(fromWorld).getAgentRectangle(a).isPointIn(point))
            {
                openWorlds.push({world: fromWorld, agent: a});
              //  console.log("point i" , point , "of agent" , a , " in " , M.getNode(fromWorld).getAgentRectangle(a));
                compute(keepLevelTil);

                return;
            }

        }


    }


}


var sunimg = new Image();
sunimg.src = "img/sun.png";

function drawBackground()
{
    var canvasBackground = document.getElementById('canvasBackground');
    var contextBackground = canvasBackground.getContext('2d');
    contextBackground.fillStyle  = "#CCCCFF";
    contextBackground.fillRect(0, 0, 640, 700);
    contextBackground.fillStyle  = worldBackgroundColor;
    contextBackground.fillRect(0, 450, 640, 700);
    contextBackground.drawImage(sunimg, 250, -100);


}

function getYLevelBulle(level)
{
    return 550-level*levelheight;
}





function showWorld(sourceWorld)
{
  let path = M.getShortestPath(M.getPointedWorld(), sourceWorld);

  if(path == undefined)
    return;

  openWorlds = [];
  let world = M.getPointedWorld();

  for(let step of path) {
      openWorlds.push({world: world, agent: step.agent});
      world = step.world;
  }

  compute(0);
  $(canvasFromWorld[path.length][sourceWorld]).addClass("currentWorld");
  checkIfInView($(canvasFromWorld[path.length][sourceWorld]));
  window.setTimeout(function() {$(canvasFromWorld[path.length][sourceWorld]).removeClass("currentWorld");},300);


}


function checkIfInView(element) {
  let parent = element.parent();

  var offset = element.offset().top + parent.scrollTop();

      var height = element.innerHeight();
      var offset_end = offset + height;
      if (!element.is(":visible")) {
          element.css({"visibility":"hidden"}).show();
          var offset = element.offset().top;
          element.css({"visibility":"", "display":""});
      }

      var visible_area_start = parent.scrollTop();
      var visible_area_end = visible_area_start + parent.innerHeight();

      if (offset-height &lt; visible_area_start) {
          parent.animate({scrollTop: offset-height}, 600);
          return false;
      } else if (offset_end > visible_area_end) {
          parent.animate({scrollTop: parent.scrollTop()+ offset_end - visible_area_end }, 600);
          return false;

      }
      return true;
}


function initGUI()
{
  $('#canvasRealWorld').unbind();

  $('#canvasRealWorld').bind('mousemove',
        () => graphNodeHighlight(M.getPointedWorld()));

  $('#canvasRealWorld').bind("click",
         (evt) => modifyOpenWorldsClick(0, $('#canvasRealWorld')[0], M.getPointedWorld())(evt));

  $('#canvasBackground').mousemove( () => graphNodeNoHighlight());

  $('#canvasBackground').click( function() {
       openWorlds = []; compute(0)}
     );

}




$().ready(initGUI);





function showEpistemicModel(M)
{
  showMEstar(M, [M.getPointedWorld()], undefined, undefined, 0);
}

function compute(fromlevel)
{
  var canvas = document.getElementById('canvas');
  var context = canvas.getContext('2d');


  if(fromlevel == undefined)
  {
       showEpistemicModel(M);
       openWorlds = [];
       fromlevel = 0;
  }

  if(openWorlds.length > 0)
    $('#explanationGUI').hide();

  context.clearRect(0, 0, canvas.width, canvas.height);

  drawBackground();

  if(fromlevel == 0)
  {
         canvasFromWorld[0] = {};
         canvasFromWorld[0][M.getPointedWorld()] = $('#canvasRealWorld')[0];

        //  M.getNode(w).draw(getContext(document.getElementById("canvasRealWorld")));
         canvasFromWorld[0][M.getPointedWorld()].draw = function()
         { M.getNode(M.getPointedWorld()).draw(getContext(document.getElementById("canvasRealWorld"))); };

  }


  for(var level = fromlevel+1; level &lt;= maxlevel; level++)
  {
    $('#level-content' + level).empty();
    //$('#level' + level).fadeOut();
    $('#level' + level).hide();
  }





  var level = 0;
  for(var worldagent of openWorlds)
  {
      level++;

      var u = worldagent.world;

      var y = getYLevelBulle(level);
      var x1 = getWorldPosition(level-1, u).x
      var y1 = getWorldPosition(level-1, u).y;

      x1 += M.getNode(u).getAgentRectangle(worldagent.agent).x1
                 + M.getNode(u).getAgentRectangle(worldagent.agent).w/2;

      y1 += M.getNode(u).getAgentRectangle(worldagent.agent).y1
                + M.getNode(u).getAgentRectangle(worldagent.agent).h/2 - 96;

      drawThinkingCircles(context, x1, y1, x1, y+100);

      if(level >= fromlevel)
      {

            //var allSuccessors = M.getSuccessors(worldagent.world, worldagent.agent);
            /*var successors;
            if(allSuccessors.length > 4)
            {
                let i1 = Math.floor(Math.random() * allSuccessors.length);
                let i2 = Math.floor(Math.random() * allSuccessors.length);
                while(i2 == i1)
                {
                  i2 = Math.floor(Math.random() * allSuccessors.length);
                }
                let i3 = Math.floor(Math.random() * allSuccessors.length);
                while((i3 == i1) || (i3 == i2))
                {
                  i3 = Math.floor(Math.random() * allSuccessors.length);
                }
                successors = new Array();
                successors.push(allSuccessors[i1]);
                successors.push(allSuccessors[i2]);
                successors.push(allSuccessors[i3]);

            }
            else {*/
            let successors = M.getSuccessors(worldagent.world, worldagent.agent);;
          //  }


            $('#level-content' + level).empty();
            //$('#level' + level).fadeIn();
            $('#level' + level).show();
            canvasFromWorld[level] = {};

            let levelWidth;


            if(successors.length == 0) {
                $('#level' + level).addClass("error");
                levelWidth = 64;
            }
            else {
              //on tronque
            //  successors = successors.slice(0, 3);
              $('#level' + level).removeClass("error");

              let firstSuccessor = true;
              for(let u of successors)
                {
                    if(!firstSuccessor)
                      $('#level-content' + level).append('&lt;div class="orBetweenWorlds"> or &lt;/div>');

                    let canvasWorld = getNewCanvas();
                    canvasFromWorld[level][u] = canvasWorld;
                    $('#level-content' + level).append(canvasWorld);
                //    M.getNode(u).draw(getContext(canvasWorld));

                    canvasWorld.draw = function()
                    {
                      M.getNode(u).draw(getContext(canvasWorld));
                    }


                    canvasWorld.addEventListener('mousemove',
                          function() {graphNodeHighlight(u);});


                    canvasWorld.addEventListener('mouseup',
                          modifyOpenWorldsClick(level, canvasWorld, u), false);

                    firstSuccessor = false;

                }

                levelWidth = successors.length * canvasWorldWidth+64;
              }

              if(levelWidth > getMaxLevelWidth())
                levelWidth = getMaxLevelWidth();

              let levelLeft = x1 - levelWidth / 2;

              if(levelLeft &lt; 0)
                levelLeft = 0;

              if(levelLeft > $("#canvas").width() - levelWidth)
                    levelLeft = $("#canvas").width() - levelWidth;

              $('#level' + level).css({left: levelLeft,
                                       top: getYLevelBulle(level),
                                       width: levelWidth,
                                       position:'absolute'});
          }

  }
  drawCanvasWorld();

}













function getBirdWidth()
{
    return 80/Math.max(1, Math.log(Math.abs(300-birdx)/20));

}


var birdx = 100;


function drawCanvasWorld()
{
    $(".canvasWorld").each(function () {
      let context = this.getContext('2d');

      context.beginPath();
      context.moveTo(0,0);
      context.lineTo(80+64,0);
      context.lineTo(80+64+16, 64);
      context.lineTo(-16, 64);

      context.fillStyle = worldBackgroundColor;
      context.fill();

      if(this.draw != undefined)
               this.draw(this);
      else {
        alert("no draw function")
      }
    });
}


function loop()
{
      drawCanvasWorld();

      $('#bird').css({top: 200, left: birdx, width: getBirdWidth(), position:'absolute'});
      birdx++;


      if(birdx > 600)
          birdx = -800;

      window.requestAnimationFrame(loop);
}











/**
 @param action model E
 @param openWorlds: list of "possible worlds"
 @returns the new list of possible worlds that are shown, after the execution
of action E.
*/
function getOpenWorldsAfterAction(E, openWorlds)
{
    function pickACompatibleEvent(idWorld, setOfPossibleEvents) {
      for(let e of setOfPossibleEvents) {
        let worldID = createWorldActionName(idWorld, e);

        if(M.getNode(worldID) != undefined)
            return e;
      }
      return undefined;
    }

    var newOpenWorlds = [];
    var setOfPossibleEvents = [E.getPointedAction()];

    for(let ow of openWorlds) {
        let e = pickACompatibleEvent(ow.world, setOfPossibleEvents);

        if(e == undefined)
          return newOpenWorlds;

        let worldID = createWorldActionName(ow.world, e);
        newOpenWorlds.push( {world: worldID, agent: ow.agent});

        setOfPossibleEvents = E.getSuccessors(e, ow.agent);
    }

    return newOpenWorlds;

}




/**
  @param action model E
  @returns execute action "e" of E
*/
function performAction(E)
{
  let M2 = product(M, E);

  M2.removeUnReachablePartFrom(M2.getPointedWorld());
  $( "#canvasRealWorld" ).effect( "shake" );
  M = M2;
  openWorlds = getOpenWorldsAfterAction(E, openWorlds);
  showEpistemicModel(M);
  compute(0);
  computeButtonsVisibleOrNot();





}




function performAnnouncement(announcementSchemeExpression)
{
  if(announcementSchemeExpression == undefined)
      announcementSchemeExpression = $("#formula").val();

  var E = getActionModelPublicAnnouncement(announcementSchemeExpression);

  performAction(E);

}










function performPrivateAnnouncement(agent, announcementSchemeExpression)
{
  if(announcementSchemeExpression == undefined)
      announcementSchemeExpression = $("#formula").val();

  var E = getActionModelPrivateAnnouncement(announcementSchemeExpression, agent);

  performAction(E);


}

















/**
  @param agent : "a" or "b", "a" has a girl voice and "b" has a man voice
  @param text: text to say
  @returns it performs a speech synthesis of the text text (in english)
*/
function speak(agent, text)
{
  if('speechSynthesis' in window){
    var speech = new SpeechSynthesisUtterance(text);
    speech.rate = 0.7;
    if(agent == "a")
        speech.pitch = 3.5;
    else if (agent == "b") {
      speech.pitch = 0.5;
    }
    else if (agent == "ab" ){
        speech.pitch = 2;

    }
    speech.lang = 'en-US';
    window.speechSynthesis.speak(speech);

    var phylactereTop = 450;
    /*if(agent == "a")
        $("#phylactere").css({top:phylactereTop, left:150});
    else if(agent == "b")
        $("#phylactere").css({top:phylactereTop, left:240});*/



    if(agent == "ab")
            $("#phylactere").css({top:phylactereTop, left:195});
    else if(agent == "c")
            $("#phylactere").css({top:10, left:400});
    else
    {
      var x = getWorldPosition(0, M.getPointedWorld()).x;


      x += M.getNode(M.getPointedWorld()).getAgentRectangle(agent).x1
                 + M.getNode(M.getPointedWorld()).getAgentRectangle(agent).w/2
                 - 70;

      $("#phylactere").css({top:phylactereTop, left:x});
    }

    $("#phylactere").html(text);

    $("#phylactere").fadeIn();


    window.setTimeout(function() {$("#phylactere").fadeOut();},2000);
  }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ActionModel.html">ActionModel</a></li><li><a href="ConsecutiveNumbers.html">ConsecutiveNumbers</a></li><li><a href="EpistemicModel.html">EpistemicModel</a></li><li><a href="Graph.html">Graph</a></li><li><a href="MuddyChildrenWorld.html">MuddyChildrenWorld</a></li><li><a href="PropositionalAssignmentsPostcondition.html">PropositionalAssignmentsPostcondition</a></li><li><a href="qdecPOMDP.html">qdecPOMDP</a></li><li><a href="QdecPOMDPPoliciesWorld.html">QdecPOMDPPoliciesWorld</a></li><li><a href="RussianCardsWorld.html">RussianCardsWorld</a></li><li><a href="SallyAndAnneWorld.html">SallyAndAnneWorld</a></li><li><a href="SetOfObjects.html">SetOfObjects</a></li><li><a href="TrivialPostCondition.html">TrivialPostCondition</a></li><li><a href="Valuation.html">Valuation</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addButtonAction">addButtonAction</a></li><li><a href="global.html#addButtonActionReset">addButtonActionReset</a></li><li><a href="global.html#addExplanation">addExplanation</a></li><li><a href="global.html#agentImages">agentImages</a></li><li><a href="global.html#cleanArray">cleanArray</a></li><li><a href="global.html#computeButtonsVisibleOrNot">computeButtonsVisibleOrNot</a></li><li><a href="global.html#createFormula">createFormula</a></li><li><a href="global.html#createKnowledgeBasedProgram">createKnowledgeBasedProgram</a></li><li><a href="global.html#createLitteral">createLitteral</a></li><li><a href="global.html#createWorldActionName">createWorldActionName</a></li><li><a href="global.html#esprimaToAST">esprimaToAST</a></li><li><a href="global.html#evalScript">evalScript</a></li><li><a href="global.html#formulaPrettyPrint">formulaPrettyPrint</a></li><li><a href="global.html#getOpenWorldsAfterAction">getOpenWorldsAfterAction</a></li><li><a href="global.html#getProgramCounterGraph01">getProgramCounterGraph01</a></li><li><a href="global.html#getQdecPOMDPPoliciesEventName">getQdecPOMDPPoliciesEventName</a></li><li><a href="global.html#getStringIntArrayFromStringSetTo">getStringIntArrayFromStringSetTo</a></li><li><a href="global.html#getTuplesWorldEvent">getTuplesWorldEvent</a></li><li><a href="global.html#performAction">performAction</a></li><li><a href="global.html#product">product</a></li><li><a href="global.html#products">products</a></li><li><a href="global.html#showGraph">showGraph</a></li><li><a href="global.html#showMEstar">showMEstar</a></li><li><a href="global.html#speak">speak</a></li><li><a href="global.html#unitTests">unitTests</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Mon Jun 19 2017 18:02:23 GMT+0200 (CEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
